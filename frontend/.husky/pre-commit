#!/usr/bin/env sh

# Get the project root directory
PROJECT_ROOT="$(cd "$(dirname "$0")/../.." && pwd)"

# =============================================================================
# Python Code Formatting Auto-fix (black + isort)
# =============================================================================

# Get staged Python files
PYTHON_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.py$' || true)

# Function to format Python files in a specific module directory
format_python_module() {
  MODULE_DIR="$1"
  MODULE_FILES="$2"
  MODULE_NAME="$3"

  if [ -z "$MODULE_FILES" ]; then
    return 0
  fi

  echo "  üì¶ Formatting $MODULE_NAME files..."
  cd "$MODULE_DIR" || return 1

  # Convert relative paths to absolute paths for formatting
  ABSOLUTE_FILES=""
  for file in $MODULE_FILES; do
    ABSOLUTE_FILES="$ABSOLUTE_FILES $PROJECT_ROOT/$file"
  done

  # Run black to auto-fix staged Python files
  if uv run black --version >/dev/null 2>&1; then
    echo "$ABSOLUTE_FILES" | xargs uv run black 2>/dev/null
    echo "    ‚úÖ Black formatting applied for $MODULE_NAME"
  else
    echo "    ‚ö†Ô∏è Black not available via uv in $MODULE_NAME. Skipping."
  fi

  # Run isort to auto-fix staged Python files
  if uv run isort --version >/dev/null 2>&1; then
    echo "$ABSOLUTE_FILES" | xargs uv run isort 2>/dev/null
    echo "    ‚úÖ isort formatting applied for $MODULE_NAME"
  else
    echo "    ‚ö†Ô∏è isort not available via uv in $MODULE_NAME. Skipping."
  fi

  cd "$PROJECT_ROOT"
}

if [ -n "$PYTHON_FILES" ]; then
  echo "üêç Formatting Python files with black and isort..."

  if command -v uv >/dev/null 2>&1; then
    echo "Using uv to run formatters..."

    # Group Python files by their module directory
    BACKEND_FILES=""
    EXECUTOR_FILES=""
    EXECUTOR_MANAGER_FILES=""
    SHARED_FILES=""
    CHAT_SHELL_FILES=""
    OTHER_FILES=""

    for file in $PYTHON_FILES; do
      case "$file" in
        backend/*)
          BACKEND_FILES="$BACKEND_FILES $file"
          ;;
        executor/*)
          EXECUTOR_FILES="$EXECUTOR_FILES $file"
          ;;
        executor_manager/*)
          EXECUTOR_MANAGER_FILES="$EXECUTOR_MANAGER_FILES $file"
          ;;
        shared/*)
          SHARED_FILES="$SHARED_FILES $file"
          ;;
        chat_shell/*)
          CHAT_SHELL_FILES="$CHAT_SHELL_FILES $file"
          ;;
        *)
          OTHER_FILES="$OTHER_FILES $file"
          ;;
      esac
    done

    # Format files in each module with its own pyproject.toml context
    if [ -n "$BACKEND_FILES" ] && [ -f "$PROJECT_ROOT/backend/pyproject.toml" ]; then
      format_python_module "$PROJECT_ROOT/backend" "$BACKEND_FILES" "backend"
    fi

    if [ -n "$EXECUTOR_FILES" ] && [ -f "$PROJECT_ROOT/executor/pyproject.toml" ]; then
      format_python_module "$PROJECT_ROOT/executor" "$EXECUTOR_FILES" "executor"
    fi

    if [ -n "$EXECUTOR_MANAGER_FILES" ] && [ -f "$PROJECT_ROOT/executor_manager/pyproject.toml" ]; then
      format_python_module "$PROJECT_ROOT/executor_manager" "$EXECUTOR_MANAGER_FILES" "executor_manager"
    fi

    if [ -n "$SHARED_FILES" ] && [ -f "$PROJECT_ROOT/shared/pyproject.toml" ]; then
      format_python_module "$PROJECT_ROOT/shared" "$SHARED_FILES" "shared"
    fi

    if [ -n "$CHAT_SHELL_FILES" ] && [ -f "$PROJECT_ROOT/chat_shell/pyproject.toml" ]; then
      format_python_module "$PROJECT_ROOT/chat_shell" "$CHAT_SHELL_FILES" "chat_shell"
    fi

    # For other files, try to use backend as fallback
    if [ -n "$OTHER_FILES" ] && [ -f "$PROJECT_ROOT/backend/pyproject.toml" ]; then
      format_python_module "$PROJECT_ROOT/backend" "$OTHER_FILES" "other"
    fi

  else
    # Fall back to python -m approach
    echo "Using python -m to run formatters..."
    cd "$PROJECT_ROOT"

    # Check if black is available
    if python -m black --version >/dev/null 2>&1 || python3 -m black --version >/dev/null 2>&1; then
      PYTHON_CMD="python"
      python -m black --version >/dev/null 2>&1 || PYTHON_CMD="python3"
      # Run black to auto-fix staged Python files
      echo "$PYTHON_FILES" | xargs $PYTHON_CMD -m black 2>/dev/null
      echo "‚úÖ Black formatting applied"
    else
      echo "‚ö†Ô∏è Black not installed. Skipping black formatting."
    fi

    # Check if isort is available
    if python -m isort --version >/dev/null 2>&1 || python3 -m isort --version >/dev/null 2>&1; then
      PYTHON_CMD="python"
      python -m isort --version >/dev/null 2>&1 || PYTHON_CMD="python3"
      # Run isort to auto-fix staged Python files
      echo "$PYTHON_FILES" | xargs $PYTHON_CMD -m isort 2>/dev/null
      echo "‚úÖ isort formatting applied"
    else
      echo "‚ö†Ô∏è isort not installed. Skipping isort formatting."
    fi
  fi

  # Return to project root
  cd "$PROJECT_ROOT"

  # Re-add the formatted files to staging
  echo "$PYTHON_FILES" | xargs git add
fi

# =============================================================================
# Frontend Code Formatting Check (lint-staged)
# =============================================================================

# Check if there are staged frontend files
FRONTEND_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '^frontend/' || true)

if [ -n "$FRONTEND_FILES" ]; then
  # Ensure we're in the correct directory for frontend
  cd "$PROJECT_ROOT"
  if [ ! -f "package.json" ] || ! grep -q '"name": "wecode-ai-assistant"' package.json 2>/dev/null; then
    if [ -d "frontend" ]; then
      cd frontend || exit 1
    else
      echo "Error: Cannot locate frontend directory"
      exit 1
    fi
  fi

  # Run lint-staged
  npx lint-staged

  # Run Translation Checks
  # Run Translation Checks
  echo "üåç Checking translations..."
  # We use the script relative to project root
  TRANSLATION_CHECK_SCRIPT="frontend/scripts/find-missing-translations.js"
  
  # Ensure we run from project root to resolve paths correctly
  cd "$PROJECT_ROOT"
  
  if node "$TRANSLATION_CHECK_SCRIPT"; then
     : # Success
  else
     echo "‚ùå Translation check failed. Please resolve before committing."
     exit 1
  fi
fi

# =============================================================================
# Alembic Multi-Head Detection
# =============================================================================

# Check if there are staged alembic migration files
ALEMBIC_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '^backend/alembic/versions/' || true)

if [ -n "$ALEMBIC_FILES" ]; then
  echo "üîç Checking Alembic migrations for multiple heads..."

  # Run the alembic head detection script
  ALEMBIC_CHECK_SCRIPT="$PROJECT_ROOT/scripts/hooks/check-alembic-heads.sh"

  if [ -x "$ALEMBIC_CHECK_SCRIPT" ]; then
    if ! "$ALEMBIC_CHECK_SCRIPT"; then
      echo "‚ùå Alembic multi-head check failed. Please resolve before committing."
      exit 1
    fi
  else
    echo "‚ö†Ô∏è Alembic check script not found or not executable: $ALEMBIC_CHECK_SCRIPT"
  fi
fi
