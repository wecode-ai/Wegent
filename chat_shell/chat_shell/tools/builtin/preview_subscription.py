# SPDX-FileCopyrightText: 2025 Weibo, Inc.
#
# SPDX-License-Identifier: Apache-2.0

"""Tool for previewing subscription tasks before creation.

This tool generates a preview of subscription configuration WITHOUT actually
creating the subscription. It stores the preview temporarily (5 min TTL)
for user confirmation before calling create_subscription.
"""

import json
import logging
import time
import uuid
from typing import Any, Literal, Optional

from langchain_core.callbacks import CallbackManagerForToolRun
from langchain_core.tools import BaseTool
from pydantic import BaseModel, Field

logger = logging.getLogger(__name__)

# In-memory storage for preview data with TTL
_preview_storage: dict[str, dict[str, Any]] = {}
_preview_timestamps: dict[str, float] = {}
PREVIEW_TTL_SECONDS = 300  # 5 minutes


def _store_preview(preview_id: str, data: dict) -> None:
    """Store preview data with timestamp."""
    _preview_storage[preview_id] = data
    _preview_timestamps[preview_id] = time.time()
    logger.debug(f"Stored preview {preview_id}, current count: {len(_preview_storage)}")


def _get_preview(preview_id: str) -> Optional[dict]:
    """Retrieve preview data if not expired."""
    # Check if preview exists
    if preview_id not in _preview_storage:
        return None

    # Check if expired
    timestamp = _preview_timestamps.get(preview_id, 0)
    if time.time() - timestamp > PREVIEW_TTL_SECONDS:
        # Clean up expired preview
        _cleanup_preview(preview_id)
        return None

    return _preview_storage[preview_id]


def _cleanup_preview(preview_id: str) -> None:
    """Remove preview data from storage."""
    _preview_storage.pop(preview_id, None)
    _preview_timestamps.pop(preview_id, None)


def _cleanup_expired_previews() -> None:
    """Clean up all expired previews."""
    current_time = time.time()
    expired_ids = [
        preview_id
        for preview_id, timestamp in _preview_timestamps.items()
        if current_time - timestamp > PREVIEW_TTL_SECONDS
    ]
    for preview_id in expired_ids:
        _cleanup_preview(preview_id)
    if expired_ids:
        logger.debug(f"Cleaned up {len(expired_ids)} expired previews")


class PreviewSubscriptionInput(BaseModel):
    """Input schema for preview_subscription tool."""

    display_name: str = Field(
        description="Display name for the subscription task, generated by AI based on user requirements"
    )
    description: Optional[str] = Field(
        default=None, description="Description of the subscription task"
    )

    # Trigger configuration
    trigger_type: Literal["cron", "interval", "one_time"] = Field(
        description="Trigger type: cron (cron expression), interval (fixed interval), one_time (one-time execution)"
    )

    # Cron configuration (required when trigger_type='cron')
    cron_expression: Optional[str] = Field(
        default=None,
        description="Cron expression, e.g., '0 9 * * *' means every day at 9:00",
    )

    # Interval configuration (required when trigger_type='interval')
    interval_value: Optional[int] = Field(default=None, description="Interval value")
    interval_unit: Optional[Literal["minutes", "hours", "days"]] = Field(
        default=None, description="Interval unit: minutes, hours, days"
    )

    # One-time configuration (required when trigger_type='one_time')
    execute_at: Optional[str] = Field(
        default=None,
        description="One-time execution time in ISO format, e.g., '2025-01-20T09:00:00'",
    )

    # Execution configuration
    prompt_template: str = Field(
        description="Prompt template for execution, supports variables: {{date}}, {{time}}, {{datetime}}, {{timestamp}}"
    )

    # History preservation configuration (AI decides based on task nature)
    preserve_history: bool = Field(
        default=False,
        description="Whether to preserve conversation history. Suitable for tasks requiring context continuity (e.g., daily reports, continuous monitoring)",
    )
    history_message_count: int = Field(
        default=10,
        ge=0,
        le=50,
        description="Number of history messages to preserve, only effective when preserve_history=True",
    )

    # Optional configuration
    retry_count: int = Field(
        default=1, ge=0, le=3, description="Retry count on failure"
    )
    timeout_seconds: int = Field(
        default=600, ge=60, le=3600, description="Execution timeout in seconds"
    )


class PreviewSubscriptionTool(BaseTool):
    """Preview subscription task WITHOUT creating it.

    This tool generates a preview table of subscription configuration for user
    confirmation. The preview is stored temporarily (5 min TTL) and can be
    used by create_subscription tool after user confirmation.

    Workflow:
    1. User mentions scheduling intent (e.g., "remind me every morning")
    2. AI calls this preview_subscription tool
    3. Tool returns a markdown table preview
    4. AI shows preview to user and asks for confirmation
    5. User confirms (e.g., "执行", "确认", "是的")
    6. AI calls create_subscription with preview_id
    """

    name: str = "preview_subscription"
    display_name: str = "预览订阅任务"
    description: str = (
        "Preview a subscription plan WITHOUT creating it. "
        "Use this tool FIRST when user wants to schedule recurring/periodic tasks. "
        "Returns a markdown table preview for user confirmation.\n\n"
        "Workflow:\n"
        "1. User: 'remind me every morning' / '每天早上9点提醒我喝水'\n"
        "2. AI: Call preview_subscription tool\n"
        "3. AI: Show preview table to user\n"
        "4. AI: Ask '请确认以上配置是否正确？回复「执行」创建任务，或告诉我需要修改的内容。'\n"
        "5. User: '执行' / '确认' / '是的'\n"
        "6. AI: Call create_subscription with preview_id from this tool\n\n"
        "DO NOT call create_subscription directly. Always use preview first."
    )
    args_schema: type[BaseModel] = PreviewSubscriptionInput

    # Context injection fields
    user_id: int = Field(default=0, description="Current user ID")
    team_id: int = Field(default=0, description="Current conversation's agent ID")
    team_name: str = Field(default="", description="Agent name")
    team_namespace: str = Field(default="default", description="Agent namespace")
    timezone: str = Field(default="Asia/Shanghai", description="User timezone")

    # Model configuration for subscription
    model_name: Optional[str] = Field(default=None, description="Model CRD name")
    model_namespace: str = Field(default="default", description="Model CRD namespace")

    def _run(
        self,
        display_name: str,
        trigger_type: Literal["cron", "interval", "one_time"],
        prompt_template: str,
        description: Optional[str] = None,
        cron_expression: Optional[str] = None,
        interval_value: Optional[int] = None,
        interval_unit: Optional[Literal["minutes", "hours", "days"]] = None,
        execute_at: Optional[str] = None,
        preserve_history: bool = False,
        history_message_count: int = 10,
        retry_count: int = 1,
        timeout_seconds: int = 600,
        run_manager: CallbackManagerForToolRun | None = None,
    ) -> str:
        """Synchronous run - not implemented, use async version."""
        raise NotImplementedError(
            "PreviewSubscriptionTool only supports async execution"
        )

    async def _arun(
        self,
        display_name: str,
        trigger_type: Literal["cron", "interval", "one_time"],
        prompt_template: str,
        description: Optional[str] = None,
        cron_expression: Optional[str] = None,
        interval_value: Optional[int] = None,
        interval_unit: Optional[Literal["minutes", "hours", "days"]] = None,
        execute_at: Optional[str] = None,
        preserve_history: bool = False,
        history_message_count: int = 10,
        retry_count: int = 1,
        timeout_seconds: int = 600,
        run_manager: CallbackManagerForToolRun | None = None,
    ) -> str:
        """Generate subscription preview without creating it.

        Args:
            display_name: Display name for the subscription
            trigger_type: Trigger type (cron, interval, one_time)
            prompt_template: Prompt template for execution
            description: Optional description
            cron_expression: Cron expression (for cron type)
            interval_value: Interval value (for interval type)
            interval_unit: Interval unit (for interval type)
            execute_at: Execution time (for one_time type)
            preserve_history: Whether to preserve history
            history_message_count: Number of history messages to preserve
            retry_count: Retry count on failure
            timeout_seconds: Execution timeout
            run_manager: Callback manager

        Returns:
            JSON string with preview_id and preview table
        """
        # Validate trigger configuration
        validation_error = self._validate_trigger_config(
            trigger_type=trigger_type,
            cron_expression=cron_expression,
            interval_value=interval_value,
            interval_unit=interval_unit,
            execute_at=execute_at,
        )
        if validation_error:
            return json.dumps(
                {"success": False, "error": validation_error}, ensure_ascii=False
            )

        # Generate preview_id
        preview_id = f"preview_{uuid.uuid4().hex[:8]}"

        # Build trigger config dict
        trigger_config = self._build_trigger_config(
            trigger_type=trigger_type,
            cron_expression=cron_expression,
            interval_value=interval_value,
            interval_unit=interval_unit,
            execute_at=execute_at,
        )

        # Store preview data
        preview_data = {
            "preview_id": preview_id,
            "display_name": display_name,
            "description": description,
            "trigger_type": trigger_type,
            "trigger_config": trigger_config,
            "prompt_template": prompt_template,
            "preserve_history": preserve_history,
            "history_message_count": history_message_count,
            "retry_count": retry_count,
            "timeout_seconds": timeout_seconds,
            "user_id": self.user_id,
            "team_id": self.team_id,
            "team_namespace": self.team_namespace,
            "timezone": self.timezone,
            "model_name": self.model_name,
            "model_namespace": self.model_namespace,
        }

        # Clean up expired previews first
        _cleanup_expired_previews()

        # Store the preview
        _store_preview(preview_id, preview_data)

        # Generate preview table
        preview_table = self._format_preview_table(
            display_name=display_name,
            description=description,
            trigger_type=trigger_type,
            trigger_config=trigger_config,
            prompt_template=prompt_template,
            preserve_history=preserve_history,
            history_message_count=history_message_count,
            retry_count=retry_count,
            timeout_seconds=timeout_seconds,
        )

        logger.info(
            f"[PreviewSubscriptionTool] Generated preview {preview_id} for user {self.user_id}"
        )

        return json.dumps(
            {
                "success": True,
                "preview_id": preview_id,
                "preview_table": preview_table,
                "message": "检测到您需要创建定时任务，请确认以下配置：",
            },
            ensure_ascii=False,
        )

    def _validate_trigger_config(
        self,
        trigger_type: str,
        cron_expression: Optional[str],
        interval_value: Optional[int],
        interval_unit: Optional[str],
        execute_at: Optional[str],
    ) -> Optional[str]:
        """Validate trigger configuration based on trigger type.

        Returns:
            Error message string if validation fails, None if valid
        """
        if trigger_type == "cron":
            if not cron_expression:
                return "cron_expression is required for cron trigger type"
            # Basic cron expression validation
            parts = cron_expression.split()
            if len(parts) != 5:
                return f"Invalid cron expression: expected 5 parts, got {len(parts)}"

        elif trigger_type == "interval":
            if interval_value is None:
                return "interval_value is required for interval trigger type"
            if not interval_unit:
                return "interval_unit is required for interval trigger type"
            if interval_value <= 0:
                return "interval_value must be positive"

        elif trigger_type == "one_time":
            if not execute_at:
                return "execute_at is required for one_time trigger type"

        return None

    def _build_trigger_config(
        self,
        trigger_type: str,
        cron_expression: Optional[str],
        interval_value: Optional[int],
        interval_unit: Optional[str],
        execute_at: Optional[str],
    ) -> dict[str, Any]:
        """Build trigger configuration dict based on trigger type."""
        if trigger_type == "cron":
            return {
                "expression": cron_expression,
                "timezone": self.timezone,
            }
        elif trigger_type == "interval":
            return {
                "value": interval_value,
                "unit": interval_unit,
            }
        elif trigger_type == "one_time":
            return {
                "execute_at": execute_at,
                "timezone": self.timezone,
            }
        return {}

    def _format_trigger_description(
        self, trigger_type: str, trigger_config: dict[str, Any]
    ) -> str:
        """Format a human-readable trigger description."""
        if trigger_type == "cron":
            expr = trigger_config.get("expression", "")
            tz = trigger_config.get("timezone", "UTC")
            return f"Cron表达式: `{expr}` (时区: {tz})"
        elif trigger_type == "interval":
            value = trigger_config.get("value", 0)
            unit = trigger_config.get("unit", "")
            unit_zh = {"minutes": "分钟", "hours": "小时", "days": "天"}.get(unit, unit)
            return f"每 {value} {unit_zh}执行"
        elif trigger_type == "one_time":
            execute_at = trigger_config.get("execute_at", "")
            tz = trigger_config.get("timezone", "UTC")
            return f"一次性执行于 {execute_at} (时区: {tz})"
        return ""

    def _format_preview_table(
        self,
        display_name: str,
        description: Optional[str],
        trigger_type: str,
        trigger_config: dict[str, Any],
        prompt_template: str,
        preserve_history: bool,
        history_message_count: int,
        retry_count: int,
        timeout_seconds: int,
    ) -> str:
        """Format a markdown preview table."""
        trigger_desc = self._format_trigger_description(trigger_type, trigger_config)

        # Truncate prompt template if too long
        prompt_display = prompt_template
        if len(prompt_display) > 100:
            prompt_display = prompt_display[:97] + "..."

        # Escape pipe characters in prompt for markdown table
        prompt_display = prompt_display.replace("|", "\\|")

        lines = [
            "### 订阅任务预览",
            "",
            "| 配置项 | 值 |",
            "|--------|-----|",
            f"| **任务名称** | {display_name} |",
            f"| **触发方式** | {trigger_desc} |",
            f"| **保留历史** | {'是' if preserve_history else '否'} ({history_message_count} 条) |",
            f"| **重试次数** | {retry_count} |",
            f"| **超时时间** | {timeout_seconds} 秒 |",
        ]

        if description:
            # Escape pipe in description
            desc_display = description.replace("|", "\\|")
            lines.append(f"| **描述** | {desc_display} |")

        lines.extend(
            [
                f"| **执行提示** | {prompt_display} |",
                "",
                "请确认以上配置是否正确？",
                "- 回复 **「执行」** 或 **「确认」** 创建任务",
                "- 回复 **「取消」** 放弃创建",
                "- 或告诉我需要修改的内容",
            ]
        )

        return "\n".join(lines)


def get_preview_data(preview_id: str) -> Optional[dict]:
    """Get preview data by preview_id.

    This function is used by create_subscription tool to retrieve
    the preview configuration after user confirmation.

    Args:
        preview_id: The preview ID returned by preview_subscription tool

    Returns:
        Preview data dict if found and not expired, None otherwise
    """
    return _get_preview(preview_id)


def clear_preview(preview_id: str) -> None:
    """Clear preview data after successful creation.

    Args:
        preview_id: The preview ID to clear
    """
    _cleanup_preview(preview_id)
