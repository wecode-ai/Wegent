# SPDX-FileCopyrightText: 2025 Weibo, Inc.
#
# SPDX-License-Identifier: Apache-2.0

"""Tool for creating subscription tasks via natural language conversation.

This tool allows users to create scheduled or periodic subscription tasks
through AI conversation. It supports cron expressions, fixed intervals,
and one-time executions.

In package mode (running inside backend), uses app.services.subscription directly.
In HTTP mode (standalone), makes HTTP calls to the backend API.
"""

import json
import logging
import uuid
from datetime import datetime
from typing import Any, Literal, Optional

from langchain_core.callbacks import CallbackManagerForToolRun
from langchain_core.tools import BaseTool
from pydantic import BaseModel, Field

logger = logging.getLogger(__name__)


class CreateSubscriptionInput(BaseModel):
    """Input schema for create_subscription tool."""

    display_name: str = Field(
        description="Display name for the subscription task, generated by AI based on user requirements"
    )
    description: Optional[str] = Field(
        default=None, description="Description of the subscription task"
    )

    # Trigger configuration
    trigger_type: Literal["cron", "interval", "one_time"] = Field(
        description="Trigger type: cron (cron expression), interval (fixed interval), one_time (one-time execution)"
    )

    # Cron configuration (required when trigger_type='cron')
    cron_expression: Optional[str] = Field(
        default=None,
        description="Cron expression, e.g., '0 9 * * *' means every day at 9:00",
    )

    # Interval configuration (required when trigger_type='interval')
    interval_value: Optional[int] = Field(default=None, description="Interval value")
    interval_unit: Optional[Literal["minutes", "hours", "days"]] = Field(
        default=None, description="Interval unit: minutes, hours, days"
    )

    # One-time configuration (required when trigger_type='one_time')
    execute_at: Optional[str] = Field(
        default=None,
        description="One-time execution time in ISO format, e.g., '2025-01-20T09:00:00'",
    )

    # Execution configuration
    prompt_template: str = Field(
        description="Prompt template for execution, supports variables: {{date}}, {{time}}, {{datetime}}, {{timestamp}}"
    )

    # History preservation configuration (AI decides based on task nature)
    preserve_history: bool = Field(
        default=False,
        description="Whether to preserve conversation history. Suitable for tasks requiring context continuity (e.g., daily reports, continuous monitoring)",
    )
    history_message_count: int = Field(
        default=10,
        ge=0,
        le=50,
        description="Number of history messages to preserve, only effective when preserve_history=True",
    )

    # Optional configuration
    retry_count: int = Field(
        default=1, ge=0, le=3, description="Retry count on failure"
    )
    timeout_seconds: int = Field(
        default=600, ge=60, le=3600, description="Execution timeout in seconds"
    )


class CreateSubscriptionTool(BaseTool):
    """Tool to create subscription tasks for scheduled or periodic execution.

    This tool enables users to create automated tasks through natural language
    conversation. It supports:
    - Cron expressions for complex time rules (e.g., every Monday/Wednesday/Friday)
    - Fixed intervals for simple periodic tasks (e.g., every 2 hours)
    - One-time execution for single scheduled tasks

    In package mode (running inside backend), uses app.services.subscription directly.
    In HTTP mode (standalone), makes HTTP calls to the backend API.

    AI Behavior Guidelines:
    1. Time handling: When user description is vague (e.g., 'every morning', 'every Monday'),
       provide 2-3 specific time options for user to choose from.
       Example: 'What time would you like it to execute each day? Common choices: A) 09:00 B) 10:00 C) 08:30'

    2. preserve_history decision:
       - Set to True: Tasks requiring context continuity (daily reports, progress tracking, continuous monitoring)
       - Set to False: Independent tasks per execution (scheduled reminders, periodic checks)

    3. Name generation: Generate concise, readable names based on task content
       (e.g., 'Daily Code Review', 'Monday Morning Meeting Reminder')

    4. Trigger type selection:
       - cron: Complex time rules (every Mon/Wed/Fri, 1st of every month)
       - interval: Simple fixed intervals (every 2 hours, every 30 minutes)
       - one_time: Single execution (tomorrow at 3pm)
    """

    name: str = "create_subscription"
    display_name: str = "创建订阅任务"
    description: str = (
        "Create scheduled or periodic tasks. Supports cron expressions, "
        "fixed intervals, and one-time executions. Use this tool when the user wants to "
        "set up automated recurring tasks or scheduled one-time tasks.\n\n"
        "Guidelines:\n"
        "- For vague time descriptions, ask for clarification with specific options\n"
        "- Set preserve_history=True for tasks needing context (reports, monitoring)\n"
        "- Set preserve_history=False for independent tasks (reminders, checks)\n"
        "- Use cron for complex schedules, interval for simple repeats, one_time for single runs"
    )
    args_schema: type[BaseModel] = CreateSubscriptionInput

    # Context injection fields
    user_id: int  # Current user ID
    team_id: int  # Current conversation's agent ID
    team_name: str  # Agent name
    team_namespace: str = "default"  # Agent namespace
    timezone: str = "Asia/Shanghai"  # User timezone (from request context)

    # Model configuration for subscription (use current request's model)
    model_name: Optional[str] = None  # Model CRD name
    model_namespace: str = "default"  # Model CRD namespace

    # Backend API configuration (HTTP mode)
    backend_url: Optional[str] = None

    def _run(
        self,
        display_name: str,
        trigger_type: Literal["cron", "interval", "one_time"],
        prompt_template: str,
        description: Optional[str] = None,
        cron_expression: Optional[str] = None,
        interval_value: Optional[int] = None,
        interval_unit: Optional[Literal["minutes", "hours", "days"]] = None,
        execute_at: Optional[str] = None,
        preserve_history: bool = False,
        history_message_count: int = 10,
        retry_count: int = 1,
        timeout_seconds: int = 600,
        run_manager: CallbackManagerForToolRun | None = None,
    ) -> str:
        """Synchronous run - not implemented, use async version."""
        raise NotImplementedError(
            "CreateSubscriptionTool only supports async execution"
        )

    async def _arun(
        self,
        display_name: str,
        trigger_type: Literal["cron", "interval", "one_time"],
        prompt_template: str,
        description: Optional[str] = None,
        cron_expression: Optional[str] = None,
        interval_value: Optional[int] = None,
        interval_unit: Optional[Literal["minutes", "hours", "days"]] = None,
        execute_at: Optional[str] = None,
        preserve_history: bool = False,
        history_message_count: int = 10,
        retry_count: int = 1,
        timeout_seconds: int = 600,
        run_manager: CallbackManagerForToolRun | None = None,
    ) -> str:
        """Create a subscription task asynchronously.

        Args:
            display_name: Display name for the subscription
            trigger_type: Trigger type (cron, interval, one_time)
            prompt_template: Prompt template for execution
            description: Optional description
            cron_expression: Cron expression (for cron type)
            interval_value: Interval value (for interval type)
            interval_unit: Interval unit (for interval type)
            execute_at: Execution time (for one_time type)
            preserve_history: Whether to preserve history
            history_message_count: Number of history messages to preserve
            retry_count: Retry count on failure
            timeout_seconds: Execution timeout
            run_manager: Callback manager

        Returns:
            JSON string with creation result
        """
        # Validate trigger configuration
        validation_error = self._validate_trigger_config(
            trigger_type=trigger_type,
            cron_expression=cron_expression,
            interval_value=interval_value,
            interval_unit=interval_unit,
            execute_at=execute_at,
        )
        if validation_error:
            return json.dumps(
                {"success": False, "error": validation_error}, ensure_ascii=False
            )

        # Build trigger config dict
        trigger_config = self._build_trigger_config(
            trigger_type=trigger_type,
            cron_expression=cron_expression,
            interval_value=interval_value,
            interval_unit=interval_unit,
            execute_at=execute_at,
        )

        # Generate unique subscription name
        subscription_name = self._generate_unique_name(display_name)

        try:
            # Try to use backend service (package mode)
            return await self._create_via_backend(
                name=subscription_name,
                display_name=display_name,
                description=description,
                trigger_type=trigger_type,
                trigger_config=trigger_config,
                prompt_template=prompt_template,
                preserve_history=preserve_history,
                history_message_count=history_message_count,
                retry_count=retry_count,
                timeout_seconds=timeout_seconds,
            )
        except ImportError:
            # Fall back to HTTP API (HTTP mode)
            return await self._create_via_http(
                name=subscription_name,
                display_name=display_name,
                description=description,
                trigger_type=trigger_type,
                trigger_config=trigger_config,
                prompt_template=prompt_template,
                preserve_history=preserve_history,
                history_message_count=history_message_count,
                retry_count=retry_count,
                timeout_seconds=timeout_seconds,
            )

    def _validate_trigger_config(
        self,
        trigger_type: str,
        cron_expression: Optional[str],
        interval_value: Optional[int],
        interval_unit: Optional[str],
        execute_at: Optional[str],
    ) -> Optional[str]:
        """Validate trigger configuration based on trigger type.

        Returns:
            Error message string if validation fails, None if valid
        """
        if trigger_type == "cron":
            if not cron_expression:
                return "cron_expression is required for cron trigger type"
            # Basic cron expression validation
            parts = cron_expression.split()
            if len(parts) != 5:
                return f"Invalid cron expression: expected 5 parts, got {len(parts)}"

        elif trigger_type == "interval":
            if interval_value is None:
                return "interval_value is required for interval trigger type"
            if not interval_unit:
                return "interval_unit is required for interval trigger type"
            if interval_value <= 0:
                return "interval_value must be positive"

        elif trigger_type == "one_time":
            if not execute_at:
                return "execute_at is required for one_time trigger type"
            # Validate ISO format
            try:
                datetime.fromisoformat(execute_at.replace("Z", "+00:00"))
            except ValueError as e:
                return f"Invalid execute_at format: {e}"

        return None

    def _build_trigger_config(
        self,
        trigger_type: str,
        cron_expression: Optional[str],
        interval_value: Optional[int],
        interval_unit: Optional[str],
        execute_at: Optional[str],
    ) -> dict[str, Any]:
        """Build trigger configuration dict based on trigger type."""
        if trigger_type == "cron":
            return {
                "expression": cron_expression,
                "timezone": self.timezone,
            }
        elif trigger_type == "interval":
            return {
                "value": interval_value,
                "unit": interval_unit,
            }
        elif trigger_type == "one_time":
            return {
                "execute_at": execute_at,
                "timezone": self.timezone,
            }
        return {}

    def _generate_unique_name(self, display_name: str) -> str:
        """Generate a unique subscription name based on display name."""
        # Create a short unique suffix
        suffix = uuid.uuid4().hex[:8]
        # Sanitize display name for use in identifier
        base_name = (
            display_name.lower()
            .replace(" ", "-")
            .replace("_", "-")
            .encode("ascii", "ignore")
            .decode()
        )
        # Keep only alphanumeric and hyphens
        base_name = "".join(c for c in base_name if c.isalnum() or c == "-")
        base_name = base_name[:50] if base_name else "subscription"
        return f"sub-{base_name}-{suffix}"

    def _format_trigger_summary(
        self, trigger_type: str, trigger_config: dict[str, Any]
    ) -> str:
        """Format a human-readable trigger summary."""
        if trigger_type == "cron":
            expr = trigger_config.get("expression", "")
            tz = trigger_config.get("timezone", "UTC")
            return f"Cron: {expr} ({tz})"
        elif trigger_type == "interval":
            value = trigger_config.get("value", 0)
            unit = trigger_config.get("unit", "")
            unit_zh = {"minutes": "分钟", "hours": "小时", "days": "天"}.get(unit, unit)
            return f"每 {value} {unit_zh}执行"
        elif trigger_type == "one_time":
            execute_at = trigger_config.get("execute_at", "")
            return f"一次性执行于 {execute_at}"
        return ""

    def _build_model_ref(self) -> Optional[dict[str, str]]:
        """Build model_ref dict from model_name and model_namespace.

        Returns:
            Dict with 'name' and 'namespace' if model_name is set, None otherwise
        """
        if self.model_name:
            return {
                "name": self.model_name,
                "namespace": self.model_namespace,
            }
        return None

    async def _create_via_backend(
        self,
        name: str,
        display_name: str,
        description: Optional[str],
        trigger_type: str,
        trigger_config: dict[str, Any],
        prompt_template: str,
        preserve_history: bool,
        history_message_count: int,
        retry_count: int,
        timeout_seconds: int,
    ) -> str:
        """Create subscription using backend service (package mode)."""
        from app.db.session import SessionLocal
        from app.schemas.subscription import SubscriptionCreate, SubscriptionTaskType
        from app.services.subscription.service import subscription_service

        # Build model_ref from current request's model
        model_ref = self._build_model_ref()

        logger.info(
            f"[CreateSubscriptionTool] Creating subscription via backend: "
            f"name={name}, team_id={self.team_id}, user_id={self.user_id}, "
            f"model_ref={model_ref}"
        )

        db = SessionLocal()
        try:
            subscription_data = SubscriptionCreate(
                name=name,
                namespace=self.team_namespace,
                display_name=display_name,
                description=description,
                task_type=SubscriptionTaskType.COLLECTION,
                trigger_type=trigger_type,
                trigger_config=trigger_config,
                team_id=self.team_id,
                prompt_template=prompt_template,
                preserve_history=preserve_history,
                history_message_count=history_message_count,
                retry_count=retry_count,
                timeout_seconds=timeout_seconds,
                enabled=True,
                model_ref=model_ref,
            )

            result = subscription_service.create_subscription(
                db, subscription_in=subscription_data, user_id=self.user_id
            )

            return self._format_success_response(
                subscription_id=result.id,
                name=result.name,
                display_name=result.display_name,
                trigger_type=trigger_type,
                trigger_config=trigger_config,
                next_execution_time=result.next_execution_time,
                preserve_history=preserve_history,
            )

        except Exception as e:
            logger.error(
                f"[CreateSubscriptionTool] Backend creation failed: {e}", exc_info=True
            )
            return json.dumps(
                {
                    "success": False,
                    "error": f"Failed to create subscription: {str(e)}",
                },
                ensure_ascii=False,
            )
        finally:
            db.close()

    async def _create_via_http(
        self,
        name: str,
        display_name: str,
        description: Optional[str],
        trigger_type: str,
        trigger_config: dict[str, Any],
        prompt_template: str,
        preserve_history: bool,
        history_message_count: int,
        retry_count: int,
        timeout_seconds: int,
    ) -> str:
        """Create subscription via HTTP API (HTTP mode).

        Uses the internal API endpoint which doesn't require user authentication.
        The endpoint is at /api/internal/subscriptions and accepts user_id as a query parameter.
        """
        import httpx

        if not self.backend_url:
            return json.dumps(
                {
                    "success": False,
                    "error": "Backend URL not configured. Cannot create subscription in HTTP mode.",
                },
                ensure_ascii=False,
            )

        # Build model_ref from current request's model
        model_ref = self._build_model_ref()

        logger.info(
            f"[CreateSubscriptionTool] Creating subscription via HTTP: "
            f"name={name}, team_id={self.team_id}, backend_url={self.backend_url}, "
            f"model_ref={model_ref}"
        )

        try:
            request_body = {
                "name": name,
                "namespace": self.team_namespace,
                "display_name": display_name,
                "description": description,
                "task_type": "collection",
                "trigger_type": trigger_type,
                "trigger_config": trigger_config,
                "team_id": self.team_id,
                "prompt_template": prompt_template,
                "preserve_history": preserve_history,
                "history_message_count": history_message_count,
                "retry_count": retry_count,
                "timeout_seconds": timeout_seconds,
                "enabled": True,
                "model_ref": model_ref,
            }

            async with httpx.AsyncClient(timeout=30.0) as client:
                # Use internal API endpoint with user_id as query parameter
                response = await client.post(
                    f"{self.backend_url}/api/internal/subscriptions",
                    json=request_body,
                    params={"user_id": self.user_id},
                    headers={"X-Service-Name": "chat-shell"},
                )

                if response.status_code == 200 or response.status_code == 201:
                    result = response.json()
                    return self._format_success_response(
                        subscription_id=result.get("id"),
                        name=result.get("name"),
                        display_name=result.get("display_name"),
                        trigger_type=trigger_type,
                        trigger_config=trigger_config,
                        next_execution_time=result.get("next_execution_time"),
                        preserve_history=preserve_history,
                    )
                else:
                    error_detail = response.text
                    try:
                        error_json = response.json()
                        error_detail = error_json.get("detail", response.text)
                    except Exception:
                        pass
                    return json.dumps(
                        {
                            "success": False,
                            "error": f"API returned status {response.status_code}: {error_detail}",
                        },
                        ensure_ascii=False,
                    )

        except Exception as e:
            logger.error(
                f"[CreateSubscriptionTool] HTTP creation failed: {e}", exc_info=True
            )
            return json.dumps(
                {
                    "success": False,
                    "error": f"HTTP request failed: {str(e)}",
                },
                ensure_ascii=False,
            )

    def _format_success_response(
        self,
        subscription_id: int,
        name: str,
        display_name: str,
        trigger_type: str,
        trigger_config: dict[str, Any],
        next_execution_time: Optional[datetime | str],
        preserve_history: bool,
    ) -> str:
        """Format a successful creation response."""
        # Format next execution time
        next_time_str = None
        if next_execution_time:
            if isinstance(next_execution_time, str):
                next_time_str = next_execution_time
            else:
                next_time_str = next_execution_time.isoformat()

        trigger_summary = self._format_trigger_summary(trigger_type, trigger_config)

        # Build message based on trigger type
        if next_time_str:
            message = (
                f"订阅任务创建成功！将于 {next_time_str.replace('T', ' ')} 首次执行。"
            )
        else:
            message = "订阅任务创建成功！"

        return json.dumps(
            {
                "success": True,
                "subscription": {
                    "id": subscription_id,
                    "name": name,
                    "display_name": display_name,
                    "trigger_type": trigger_type,
                    "trigger_summary": trigger_summary,
                    "next_execution_time": next_time_str,
                    "preserve_history": preserve_history,
                    "enabled": True,
                },
                "message": message,
                "management_url": f"/subscriptions/{subscription_id}",
            },
            ensure_ascii=False,
        )
