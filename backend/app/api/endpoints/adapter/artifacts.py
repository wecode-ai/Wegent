# SPDX-FileCopyrightText: 2025 Weibo, Inc.
#
# SPDX-License-Identifier: Apache-2.0

"""
Artifact API endpoints for sandbox-generated files.

Handles upload, download, and retrieval of files generated by sandbox tools
(e.g., PPT, DOCX, XLSX files created by document skills).
"""

import logging
import mimetypes
import os
from typing import List, Optional
from urllib.parse import quote

from fastapi import APIRouter, Depends, File, Form, HTTPException, UploadFile
from fastapi.responses import Response
from sqlalchemy.orm import Session

from app.api.dependencies import get_db
from app.core import security
from app.models.subtask_context import ContextStatus, ContextType, SubtaskContext
from app.models.user import User
from app.schemas.subtask_context import ArtifactListResponse, ArtifactResponse
from app.services.attachment.storage_backend import StorageError, generate_storage_key
from app.services.attachment.storage_factory import get_storage_backend

logger = logging.getLogger(__name__)

router = APIRouter()

# MIME type mappings for common artifact file types
MIME_TYPES = {
    ".pptx": "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    ".ppt": "application/vnd.ms-powerpoint",
    ".docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    ".doc": "application/msword",
    ".xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    ".xls": "application/vnd.ms-excel",
    ".pdf": "application/pdf",
    ".png": "image/png",
    ".jpg": "image/jpeg",
    ".jpeg": "image/jpeg",
    ".gif": "image/gif",
    ".svg": "image/svg+xml",
    ".html": "text/html",
    ".csv": "text/csv",
    ".json": "application/json",
    ".xml": "application/xml",
    ".zip": "application/zip",
    ".tar": "application/x-tar",
    ".gz": "application/gzip",
}


def _get_mime_type(filename: str) -> str:
    """Get MIME type from filename."""
    _, ext = os.path.splitext(filename)
    ext = ext.lower()
    # First check our custom mapping
    if ext in MIME_TYPES:
        return MIME_TYPES[ext]
    # Fall back to mimetypes module
    mime_type, _ = mimetypes.guess_type(filename)
    return mime_type or "application/octet-stream"


def _get_file_extension(filename: str) -> str:
    """Get file extension from filename."""
    _, ext = os.path.splitext(filename)
    return ext.lower()


@router.post("/upload", response_model=ArtifactResponse)
async def upload_artifact(
    file: UploadFile = File(...),
    subtask_id: int = Form(...),
    file_path: str = Form(...),
    sandbox_id: str = Form(default=""),
    db: Session = Depends(get_db),
    current_user: User = Depends(security.get_current_user),
):
    """
    Upload an artifact file generated by sandbox.

    This endpoint is called by sandbox tools after generating files.
    The file is stored in the backend storage and linked to the subtask.

    Args:
        file: The binary file data
        subtask_id: The subtask ID to link the artifact to
        file_path: Original file path in the sandbox
        sandbox_id: The sandbox ID that generated the file

    Returns:
        ArtifactResponse with artifact details
    """
    logger.info(
        f"[artifacts.py] upload_artifact: user_id={current_user.id}, "
        f"subtask_id={subtask_id}, file_path={file_path}, sandbox_id={sandbox_id}"
    )

    if not file.filename:
        raise HTTPException(status_code=400, detail="Filename is required")

    # Read file content
    try:
        binary_data = await file.read()
    except Exception as e:
        logger.error(f"Error reading uploaded artifact file: {e}")
        raise HTTPException(
            status_code=400, detail="Failed to read uploaded file"
        ) from e

    file_size = len(binary_data)
    filename = os.path.basename(file_path) if file_path else file.filename
    extension = _get_file_extension(filename)
    mime_type = _get_mime_type(filename)

    # Get storage backend
    storage_backend = get_storage_backend(db)

    # Create context record
    context = SubtaskContext(
        subtask_id=subtask_id,
        user_id=current_user.id,
        context_type=ContextType.ARTIFACT.value,
        name=filename,
        status=ContextStatus.READY.value,
        binary_data=b"",  # Empty - stored via storage_backend
        image_base64="",
        extracted_text="",
        text_length=0,
        error_message="",
        type_data={
            "original_filename": filename,
            "file_extension": extension,
            "file_size": file_size,
            "mime_type": mime_type,
            "file_path": file_path,
            "sandbox_id": sandbox_id,
            "storage_backend": storage_backend.backend_type,
            "storage_key": "",
        },
    )
    db.add(context)
    db.flush()

    # Generate storage key and save
    storage_key = generate_storage_key(context.id, current_user.id)
    context.type_data = {
        **context.type_data,
        "storage_key": storage_key,
    }

    try:
        metadata = {
            "filename": filename,
            "mime_type": mime_type,
            "file_size": file_size,
            "user_id": current_user.id,
        }
        storage_backend.save(storage_key, binary_data, metadata)
    except StorageError as e:
        logger.exception(f"Failed to save artifact {context.id} to storage: {e}")
        db.rollback()
        raise HTTPException(
            status_code=500, detail="Failed to save artifact"
        ) from e

    db.commit()
    db.refresh(context)

    logger.info(
        f"Artifact uploaded successfully: id={context.id}, filename={filename}, "
        f"size={file_size}, storage_backend={storage_backend.backend_type}"
    )

    return ArtifactResponse.from_context(context)


@router.get("/{artifact_id}", response_model=ArtifactResponse)
async def get_artifact(
    artifact_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(security.get_current_user),
):
    """
    Get artifact details by ID.

    Returns:
        Artifact details including status and metadata
    """
    context = (
        db.query(SubtaskContext)
        .filter(
            SubtaskContext.id == artifact_id,
            SubtaskContext.context_type == ContextType.ARTIFACT.value,
        )
        .first()
    )

    if context is None:
        raise HTTPException(status_code=404, detail="Artifact not found")

    # Check access permission
    has_access = context.user_id == current_user.id

    if not has_access and context.subtask_id > 0:
        from app.models.subtask import Subtask
        from app.models.task import TaskResource
        from app.models.task_member import MemberStatus, TaskMember

        subtask = db.query(Subtask).filter(Subtask.id == context.subtask_id).first()
        if subtask:
            task = (
                db.query(TaskResource)
                .filter(
                    TaskResource.id == subtask.task_id,
                    TaskResource.kind == "Task",
                    TaskResource.user_id == current_user.id,
                )
                .first()
            )
            if task:
                has_access = True
            else:
                task_member = (
                    db.query(TaskMember)
                    .filter(
                        TaskMember.task_id == subtask.task_id,
                        TaskMember.user_id == current_user.id,
                        TaskMember.status == MemberStatus.ACTIVE,
                    )
                    .first()
                )
                has_access = task_member is not None

    if not has_access:
        raise HTTPException(status_code=404, detail="Artifact not found")

    return ArtifactResponse.from_context(context)


@router.get("/{artifact_id}/download")
async def download_artifact(
    artifact_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(security.get_current_user),
):
    """
    Download the artifact file.

    Returns:
        File binary data with appropriate content type
    """
    context = (
        db.query(SubtaskContext)
        .filter(
            SubtaskContext.id == artifact_id,
            SubtaskContext.context_type == ContextType.ARTIFACT.value,
        )
        .first()
    )

    if context is None:
        raise HTTPException(status_code=404, detail="Artifact not found")

    # Check access permission
    has_access = context.user_id == current_user.id

    if not has_access and context.subtask_id > 0:
        from app.models.subtask import Subtask
        from app.models.task import TaskResource
        from app.models.task_member import MemberStatus, TaskMember

        subtask = db.query(Subtask).filter(Subtask.id == context.subtask_id).first()
        if subtask:
            task = (
                db.query(TaskResource)
                .filter(
                    TaskResource.id == subtask.task_id,
                    TaskResource.kind == "Task",
                    TaskResource.user_id == current_user.id,
                )
                .first()
            )
            if task:
                has_access = True
            else:
                task_member = (
                    db.query(TaskMember)
                    .filter(
                        TaskMember.task_id == subtask.task_id,
                        TaskMember.user_id == current_user.id,
                        TaskMember.status == MemberStatus.ACTIVE,
                    )
                    .first()
                )
                has_access = task_member is not None

    if not has_access:
        raise HTTPException(status_code=404, detail="Artifact not found")

    # Get binary data from storage
    storage_key = context.storage_key
    if not storage_key:
        raise HTTPException(status_code=500, detail="Artifact storage key not found")

    storage_backend = get_storage_backend(db)
    binary_data = storage_backend.get(storage_key)

    if binary_data is None:
        logger.error(
            f"Failed to retrieve binary data for artifact {artifact_id}, "
            f"storage_backend={context.storage_backend}, storage_key={storage_key}"
        )
        raise HTTPException(
            status_code=500, detail="Failed to retrieve artifact data"
        )

    # Encode filename for Content-Disposition header
    encoded_filename = quote(context.original_filename)

    return Response(
        content=binary_data,
        media_type=context.mime_type,
        headers={
            "Content-Disposition": f"attachment; filename*=UTF-8''{encoded_filename}"
        },
    )


@router.get("/subtask/{subtask_id}", response_model=ArtifactListResponse)
async def get_artifacts_by_subtask(
    subtask_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(security.get_current_user),
):
    """
    Get all artifacts for a subtask.

    Returns:
        List of artifacts linked to the subtask
    """
    contexts = (
        db.query(SubtaskContext)
        .filter(
            SubtaskContext.subtask_id == subtask_id,
            SubtaskContext.context_type == ContextType.ARTIFACT.value,
        )
        .order_by(SubtaskContext.created_at)
        .all()
    )

    # Filter by access permission
    accessible_contexts = []
    for context in contexts:
        has_access = context.user_id == current_user.id

        if not has_access and context.subtask_id > 0:
            from app.models.subtask import Subtask
            from app.models.task import TaskResource
            from app.models.task_member import MemberStatus, TaskMember

            subtask = db.query(Subtask).filter(Subtask.id == context.subtask_id).first()
            if subtask:
                task = (
                    db.query(TaskResource)
                    .filter(
                        TaskResource.id == subtask.task_id,
                        TaskResource.kind == "Task",
                        TaskResource.user_id == current_user.id,
                    )
                    .first()
                )
                if task:
                    has_access = True
                else:
                    task_member = (
                        db.query(TaskMember)
                        .filter(
                            TaskMember.task_id == subtask.task_id,
                            TaskMember.user_id == current_user.id,
                            TaskMember.status == MemberStatus.ACTIVE,
                        )
                        .first()
                    )
                    has_access = task_member is not None

        if has_access:
            accessible_contexts.append(context)

    artifacts = [ArtifactResponse.from_context(ctx) for ctx in accessible_contexts]

    return ArtifactListResponse(artifacts=artifacts, total=len(artifacts))


@router.delete("/{artifact_id}")
async def delete_artifact(
    artifact_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(security.get_current_user),
):
    """
    Delete an artifact.

    Only the owner can delete an artifact.

    Returns:
        Success message
    """
    context = (
        db.query(SubtaskContext)
        .filter(
            SubtaskContext.id == artifact_id,
            SubtaskContext.context_type == ContextType.ARTIFACT.value,
            SubtaskContext.user_id == current_user.id,
        )
        .first()
    )

    if context is None:
        raise HTTPException(status_code=404, detail="Artifact not found")

    # Delete from storage
    if context.storage_key:
        try:
            storage_backend = get_storage_backend(db)
            storage_backend.delete(context.storage_key)
        except StorageError as e:
            logger.warning(f"Failed to delete artifact {artifact_id} from storage: {e}")

    db.delete(context)
    db.commit()

    logger.info(f"Artifact {artifact_id} deleted by user {current_user.id}")

    return {"message": "Artifact deleted successfully"}
